@startuml
' + - public
' # - protected
' - - private 
' ~ - package private

''' GameController '''
class GameController {
    - IsMenuActive : bool
    - file : FileController
    + RunCommand(string input) : void
    + GameFactory(GameConfig config) : Game
    + Start() : void
    + NewGame() : void
    + LoadGame() : void
    + TestMode() : void
}

''' Game '''
abstract class Game {
    + Grid : Grid
    + PlayerOne : Player
    + PlayerTwo: Player
    + IsGameActive : bool
    # AllowedDiscChars : char[]
    + MoveSequence : List<Move>
    - redoStack : Stack<Move>
    + file : FileController
    # computerStrategy : IComputerStrategy
    # Game()
    + GetInputGame() : string
    - DocumentMove(Move move) : void
    - Undo() : void
    - Redo() : bool
    - PlayMoveSequence(int moveCount) : bool
    + TryHandleCommand(string input) : bool
    # VerifyDiscChar() : bool
    + TryParseMove(string input, out int lane) : bool
    + PlayerTurn(Player player) : bool
    + ComputerTurn(Player player) : bool
    + TestLoop() : void    
    + {abstract} CheckBoard() : void
    + GameLoop() : void
    + Reset() : void
    + PrintPlayerData() : void
}

' Game Subclasses
class LineUpClassic {
    + CheckBoard() : void
}

class LineUpBasic {
    + CheckBoard() : void
}

class LineUpSpin {
    + CheckBoard() : void
}

''' Grid '''
class Grid {
    + Board : Disc[][]
    + Orientation : enum
    + orientation : Orientation
    + WinLength : int
    + TurnCounter : int
    + IncrementTurnCounter() : void
    + DecrementTurnCounter() : void
    + SetTurnCounter(int num) : bool
    + IncrementOrientation() : void
    + IsTieGame(Player p1, Player p2) : bool
    + AddDisc(Move move) : bool
    + ApplyGravity() : void
    + Spin() : void
    + DrawGrid() : void
    + CheckWinCondition() : bool
    + Reset() : void
}

enum Orientation {
    North
    East
    South
    West
}

'''Disc'''
abstract class Disc {
    + Symbol : string
    + IsPlayerOne : bool
    + DiscReturn : Dictionary<string, int>[]
    + CreateDisc(char discType, bool isPlayerOne) : Disc
    + {abstract} Clone() : Disc
    + {abstract} ApplyEffects(Disc[][] Board, int lane) : bool
    + {abstract} HasDiscRemaining(Player player) : bool
    + {abstract} WithdrawDisc(Player player) : void
}

class OrdinaryDisc {
    + ApplyEffects(Disc[][] Board, int lane) : bool
    + Clone() : Disc
    + HasDiscRemaining(Player player) : bool
    + WithdrawDisc(Player player) : void
}

class BoringDisc {
    + ApplyEffects(Disc[][] Board, int lane) : bool
    + Clone() : Disc
    + HasDiscRemaining(Player player) : bool
    + WithdrawDisc(Player player) : void
}

class ExplodingDisc {
    + ApplyEffects(Disc[][] Board, int lane) : bool
    + Clone() : Disc
    + HasDiscRemaining(Player player) : bool
    + WithdrawDisc(Player player) : void
}

class MagneticDisc {
    + ApplyEffects(Disc[][] Board, int lane) : bool
    + Clone() : Disc
    + HasDiscRemaining(Player player) : bool
    + WithdrawDisc(Player player) : void
}

class Move {
    + Disc : Disc 
    + Lane : int
}

''' Player ''' 
class Player {
    + DiscBalance : Dictionary<string, int>
    + IsHuman : bool
    + HasDiscBalanceRemaining() : bool
    + ResetDiscBalance(Dictionary<string, int> DiscBalance_) : void
    + ReturnDisc(Dictionary<string, int> discReturned) : void
}

interface IComputerStrategy {
    SelectMove(Grid grid, Player player) : Move
}

class BasicComputerStrategy {
    - random : Random
    + SelectMove(Grid grid, Player player) : Move
    - FindWinningMove(Grid grid, Player player) : Move
    - FindRandomMove(Grid grid, Player player) : Move
    - TrySimulateMove(Grid original, Disc disc, Int lane, out Grid simulated) : bool
    - CopyGrid(Grid original) : Grid
}

''' IOController '''
class IOController {
    + PrintGameBanner() : void
    + PrintDiscInventory(Dictionary<string, int> discBalance) : void
    + PrintGameStatus(Grid grid, int winLength) : void
    + PrintGreen(string text) : void
    + PrintCyan(string text) : void
    + PrintYellow(string text) : void
    + PrintError(string text) : void
    + PrintSuccess(string text) : void
    + PrintMenu() : void
    + PrintBannerNewGame() : void
    + PrintHelp() : void
    + PrintInGameHelp() : void
    + PrintSaveFiles(string[] saveFiles) : void
    + PrintWinner(bool P1, bool P2) : void
    + GetInputMenu() : int
    + GetInputLoad(string[] saveFiles) : string
    + GetInputNewGame() : GameConfig
}

''' GameConfig '''
class GameConfig {
    + PlayerMode : enum
    + GameMode : enum
    + SelectedPlayerMode : PlayerMode
    + SelectedGameMode : GameMode
    + GridHeight : int
    + GridWidth : int
    + GameConfig()
    + SetGameMode(GameMode mode) : bool
    + SetPlayerMode(PlayerMode mode) : bool
    + SetGridHeight(int rows) : bool
    + SetGridWidth(int cols) : bool
}

enum PlayerMode {
    HvH
    HvC
}

enum GameMode {
    Classic
    Basic
    Spin
}

''' FileController '''
class FileController {
    + GameSerialization(Game game) : void
    + GetSaves() : string[]
    + GameDeserialization(string filePath) : Game
}

' Relationships
' Game Subclasses
Game <|-- LineUpClassic : inherits
Game <|-- LineUpBasic : inherits
Game <|-- LineUpSpin : inherits
Game *-- Player
Game *-- "1" Grid
Game *-- Move
Game --> IOController
Game --> BasicComputerStrategy

' GameController
GameController ..> Game : creates
GameController --> IOController
GameController::LoadGame *-- FileController : uses


' GameConfig
GameConfig <-- PlayerMode : uses
GameConfig <-- GameMode: uses

' Player
BasicComputerStrategy <.. IComputerStrategy

' Disc Subclasses
Disc <|-- OrdinaryDisc : inherits
Disc <|-- BoringDisc : inherits
Disc <|-- ExplodingDisc : inherits
Disc <|-- MagneticDisc : inherits

' Grid
Grid <-- Orientation : uses
Grid *-- Disc


' IOController
IOController ..> GameConfig : creates

@enduml
