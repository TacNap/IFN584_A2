@startuml
' + - public
' # - protected
' - - private 
' ~ - package private

''' GameController '''
class GameController {
    IsMenuActive : bool
    RunCommand(string input) : void
    GameFactory(GameConfig config) : Game
    Start() : void
    NewGame() : void
    LoadGame() : void
}
note left of GameController::GameFactory
    This creates Game objects
end note

''' Game '''
abstract class Game {
    Grid : Grid
    PlayerOne : Player
    PlayerTwo: Player
    MoveSequence : String
    IOController : IOController
    FileController : FileController
    CreateDisc() : Disc
    {abstract} GameLoop() : void
    ResetGame() : void
}
note left of Game::TurnCounter
    Could also belong on Grid
end note
note left of Game::ResetGame
    May not need this.
    Depends on how we treat loading, 
    grid sizing 
    and quitting
end note

' Game Subclasses
class LineUpClassic {
    GameLoop() : void
}

class LineUpBasic {
    GameLoop() : void
}

class LineUpSpin {
    GameLoop() : void
}

''' Grid '''
class Grid {
    Board : Disc[][]
    Orientation : enum
    orientation : Orientation
    WinLength : int
    TurnCounter : int
    IncrementTurnCounter() : void
    DecrementTurnCounter() : void
    SetTurnCounter() : void
    IsTieGame(Player p1, Player p2) : bool
    AddDisc(int lane) : bool
    ApplyGravity(int lane) : void
    Spin() : void
    DrawGrid() : void
    CheckWinCondition() : bool

}

enum Orientation {
    0
    90
    180
    270
}

'''Disc'''
abstract class Disc {
    Symbol : string
    IsPlayerOne : bool
    {abstract} ApplyEffects(Disc[][] Board, int lane) : void
}

class OrdinaryDisc {
    ApplyEffects(Disc[][] Board, int lane) : void
}

class BoringDisc {
    ApplyEffects(Disc[][] Board, int lane) : void
}

class ExplosiveDisc {
    ApplyEffects(Disc[][] Board, int lane) : void
}

class MagneticDisc {
    ApplyEffects(Disc[][] Board, int lane) : void
}

''' Player '''
abstract class Player {
    DiscBalance : Dictionary<string, int>
    HasDiscRemaining() : bool
    WithdrawDisc(Disc disc) : void
    {abstract} PlayTurn() : void
}

class Human {
    PlayTurn() : void
}

class Computer {
    PlayTurn() : void
}

''' IOController '''
class IOController {
    PrintMenu() : void
    PrintWinner(bool P1, bool P2) : void
    GetInputMenu() : string
    GetInputNewGame() : GameConfig

}

''' GameConfig '''
class GameConfig {
    PlayerMode : enum
    GameMode : enum
    GridHeight : int
    GridWidth : int
}

enum PlayerMode {
    HvH
    HvC
}

enum GameMode {
    Classic
    Basic
    Spin
}
''' FileController '''
class FileController {
    GridSerialization() : void
    GridDeserialization() : void
}

' Relationships
' Game Subclasses
Game <|-- LineUpClassic : inherits
Game <|-- LineUpBasic : inherits
Game <|-- LineUpSpin : inherits
Game <-- Player

Game::Grid *-- "1" Grid : uses
Game - IOController

' GameController
GameController - Game
GameController <-- IOController
GameController::LoadGame <-- FileController : uses

' GameConfig
GameConfig::PlayerMode <-- PlayerMode : uses
GameConfig::GameMode <-- GameMode: uses

' Player Subclasses
Player <|-- Human : inherits
Player <|-- Computer : inherits

' Disc Subclasses
Disc <|-- OrdinaryDisc : inherits
Disc <|-- BoringDisc : inherits
Disc <|-- ExplosiveDisc : inherits
Disc <|-- MagneticDisc : inherits

' Grid
Grid::Orientation <-- Orientation : uses
Grid::Board <-- Disc : uses

' IOController
IOController <-- GameConfig

@enduml